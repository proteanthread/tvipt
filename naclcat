#!/usr/bin/env python3
#
# Requires PyNaCl.
#
#  A serialized encrypted packet looks like:
#
#  Byte  Example  Description
#  ---------------------------
#  1     0x02     packet length high byte
#  2     0x08     packet length low byte
#
#                 The first two bytes are a big-endian unsigned 16-bit integer that
#                 specifies the number of packet bytes that follow.  In this example,
#                 the value 0x0208 (decimal 520) means the packet will contain 24 nonce
#                 bytes (contant for all packets) and 496 ciphertext bytes.
#
#                 Because each packet has a nonce and at the ciphertext always contains
#                 a 16-byte nonce and 1 encrypted data byte, the minimum valid packet
#                 length is 41 bytes.
#
#  3     0xAB     first nonce byte
#  ...   ...
#  26    0x7E     last nonce byte
#
#                 Bytes 3-26 contain the 24-byte Salsa20 nonce.
#
#  27    0x00     first ciphertext byte
#  ...   ...
#  496   0xFF     last ciphertext byte
#
#                 Bytes 27-496 (in this example) contain the Salsa20 ciphertext and MAC.

import binascii
import io
import os
import pty
import pwd
import sys
import tty
from argparse import ArgumentParser

import nacl.secret
import nacl.utils

PACKET_LEN_FIELD_SIZE = 2
NONCE_FIELD_SIZE = nacl.secret.SecretBox.NONCE_SIZE
MAC_OVERHEAD = 16

MIN_PACKET_LEN = NONCE_FIELD_SIZE + MAC_OVERHEAD + 1
MAX_PACKET_LEN = 65535

STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2

verbose = False


def log_d(msg):
    if verbose:
        sys.stderr.write('%s\n' % msg)


def hex_str(b, limit=8):
    truncated = False
    if limit is not None and len(b) > limit:
        truncated = True
        b = b[:limit]
    s = '0x' + str(binascii.hexlify(b), 'ascii').upper()
    if truncated:
        s += '...'
    return s


def encrypt(box, infile, outfile, max_packet_len=MAX_PACKET_LEN):
    packet_num = 0

    def log_e(msg):
        if verbose:
            sys.stderr.write('<e> [#%d] %s\n' % (packet_num, msg))

    while True:
        log_e('start')

        # Account for the 24-byte nonce, 16-byte MAC.
        plaintext = infile.read(max_packet_len - NONCE_FIELD_SIZE - MAC_OVERHEAD)
        if not plaintext:
            break
        log_e('read %d plaintext bytes' % len(plaintext))

        nonce = nacl.utils.random(NONCE_FIELD_SIZE)
        e_msg = box.encrypt(plaintext, nonce)
        log_e('produced %d ciphertext bytes' % len(e_msg.ciphertext))

        packet_len = len(e_msg.nonce) + len(e_msg.ciphertext)
        packet_len_bytes = packet_len.to_bytes(PACKET_LEN_FIELD_SIZE, byteorder='big', signed=False)
        log_e('packet_len = %d bytes' % packet_len)

        outfile.write(packet_len_bytes)
        log_e('wrote packet_len_bytes')

        outfile.write(e_msg.nonce)
        log_e('wrote nonce_bytes')

        outfile.write(e_msg.ciphertext)
        log_e('ciphertext')

        outfile.flush()
        log_e('done')

        packet_num += 1

    log_e('EOF')


def decrypt(box, infile, outfile):
    packet_num = 0

    def log_d(msg):
        if verbose:
            sys.stderr.write('<d> [#%d] %s\n' % (packet_num, msg))

    while True:
        log_d('start')

        packet_len_bytes = infile.read(PACKET_LEN_FIELD_SIZE)
        if not packet_len_bytes:
            break
        log_d('read packet_len_bytes = %s' % hex_str(packet_len_bytes))
        packet_len = int.from_bytes(packet_len_bytes, byteorder='big', signed=False)

        nonce_bytes = infile.read(NONCE_FIELD_SIZE)
        if not nonce_bytes:
            break
        log_d('read nonce_bytes')

        ciphertext = infile.read(packet_len - NONCE_FIELD_SIZE)
        if not ciphertext:
            break
        log_d('read ciphertext')

        plaintext = box.decrypt(ciphertext, nonce=nonce_bytes)
        log_d('decrypt ok')

        outfile.write(plaintext)
        outfile.flush()
        log_d('done')

        packet_num += 1

    log_d('EOF')


def shell(box, infile, outfile):
    def log_s(msg):
        if verbose:
            sys.stderr.write('<s> %s\n' % msg)

    pw_ent = pwd.getpwuid(os.getuid())
    pw_shell = pw_ent.pw_shell
    log_s('shell "%s"' % pw_shell)

    def read_shell_stdout(fd):
        # Called to read bytes that the shell has written to its stdout
        data = os.read(fd, 1024)
        outfile.write(data)
        return data

    def supply_shell_stdin(fd):
        # Called to read bytes to make available on the shell's stdin
        return infile.read(1024)

    pty.spawn(['/bin/bash', '-l', '-i'], read_shell_stdout, supply_shell_stdin)


def main():
    global verbose

    parser = ArgumentParser(description='Encrypt or decrypt stdin/stdout with a secret key')

    mode_group = parser.add_mutually_exclusive_group(required=True)
    mode_group.add_argument('-e', '--encrypt', action='store_true',
                            help='Read plaintext from in, write ciphertext to out')
    mode_group.add_argument('-d', '--decrypt', action='store_true',
                            help='Read ciphertext from in, write plaintext to out')
    mode_group.add_argument('-s', '--shell', action='store_true',
                            help='Spawn an interactive shell and encrypt/decrypt its pty')

    parser.add_argument('key', help='Salsa20 secret key (64 hexadecimal chars)')
    parser.add_argument('-l', '--length', default=MAX_PACKET_LEN,
                        help='Maximum encryption mode packet length')
    parser.add_argument('-v', '--verbose', default=False, action='store_true',
                        help='Write debugging output to stderr (output may compromise security)')
    parser.add_argument('-i', '--input', default='/dev/stdin',
                        help='Read from this input (default /dev/stdin)')
    parser.add_argument('-o', '--output', default='/dev/stdout',
                        help='Write to this output (default /dev/stdout)')

    args = parser.parse_args()
    verbose = args.verbose

    infile = io.open('/dev/stdin', 'rb', buffering=0)
    outfile = io.open('/dev/stdout', 'wb', buffering=0)

    if infile.isatty():
        log_d('infile %s is a tty, setting raw' % infile)
        tty.setraw(infile.fileno())

    if outfile.isatty():
        log_d('outfile %s is a tty, setting raw' % infile)
        tty.setraw(outfile.fileno())

    hex_key = args.key
    if len(hex_key) != 64:
        print('Key must be 64 hexadecimal characters')
        sys.exit(1)
    key = bytes.fromhex(hex_key)

    box = nacl.secret.SecretBox(key)

    if args.encrypt:
        max_packet_len = int(args.length)
        if max_packet_len < MIN_PACKET_LEN or max_packet_len > MAX_PACKET_LEN:
            print('Max packet length must be >= %d and <= %d' % (MIN_PACKET_LEN, MAX_PACKET_LEN))
            sys.exit(2)

        encrypt(box, infile, outfile, max_packet_len=max_packet_len)
    elif args.decrypt:
        decrypt(box, infile, outfile)
    else:
        shell(box, infile, outfile)

    sys.exit(0)


if __name__ == '__main__':
    main()
